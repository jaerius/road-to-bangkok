# EOA 만들기 실습

이더리움 계정 챕터에서 살펴봤듯이, 이더리움 계정은 ‘이더리움 잔액이 있는 엔티티’이다. 

이런 이더리움 잔액이 있는 엔티티인 이더리움 계정에 대해 본 미션에서는 실습을 통해 EOA에 대해 더 자세히 알아보고자 한다.

## 본 실습의 목표

이더리움 주소가 어떻게 만들어지는지 직접 실습해봄으로써 블록체인 상에서의 Account에 대한 이해도를 높일 수 있다. 

## 사전 준비

- ethers.js 라이브러리
- NodeJS
- VSCode

## 미션 제출 방법

### EOA 복습

들어가기 앞서 EOA는 개인이 관리하는 이더리움 계정을 의미하며, private key를 통해 이더리움 주소를 생성하는데 사용된다. 이더리움 주소를 만드는 과정을 요약해보면 다음과 같다. 

1. private key 생성한다 
2. private key를 사용하여 ECDSA(타원 곡선 디지털 서명 알고리즘)에 기반한 public key를 생성한다 

서명 알고리즘을 출력하기 전에 메시지 해시 필요하다. 

1. 생성된 public key를 통한 Keccack-256 해시함수에 입력하여 32 byte의 해시값 출력한다.
2. 32byte 중에서 마지막 20byte가 이더리움 주소로 사용된다. 

위의 step에 맞춰 실습을 진행할 것이다. 차근차근 시작해보자! 

## Ethereum Account 만들기 실습

### VSCode로 프로젝트 만들기

VSCode를 열어 터미널에서 `mkdir` 명령어를 통해 ethereum-account-practice 프로젝트를 만든다.

cd 명령어를 통해 우리가 만든 `ethereum-account-practice`  디렉토리로 이동한다. 

그러면 명령어의 위치가 ethereum-account-practice로 바귄다. 

<img width="333" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 26 39" src="https://github.com/seungmiKim1/road-to-bangkok/assets/89903766/4ab1aeec-49b2-471b-a6e4-e83bdfce8230">

### npm init -y 명령어 실행

그런 다음, pacakge.json 파일을 생성하기 위해 터미널에 npm init -y 를 해준다. 

그런 다음, npm install ethers 를 입력해주시면 ethers 라이브러리 설치가 완료된다! 

![image](https://github.com/seungmiKim1/road-to-bangkok/assets/89903766/28bc0335-e10a-48b1-8181-8357747a007b)



### 실습을 위한 Index.js 파일 만들기
<img width="336" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11 33 27" src="https://github.com/seungmiKim1/road-to-bangkok/assets/89903766/31c3b741-fe16-4d50-8b63-dcbef879a801">


프로젝트의 디렉토리 하위에는 src 디렉토리 생성과 함께, index.js 파일을 함께 만든다. 

### Index.js

```jsx
const { ethers } = require('ethers');
```

위에서 npm install ethers로 설치한 ethers 라이브러리를 index.js 파일 안에서 사용하기 위해 선언한다. 

```jsx
const wallet = ethers.Wallet.createRandom();
console.log('random wallet:',wallet);
```

ethers에 정의된 Wallet 클래스를 주로 사용한다. (Wallet 클래스에 대해 자세한 내용은 [https://docs.ethers.org/v6/api/wallet/](https://docs.ethers.org/v6/api/wallet/) 에서 확인하실 수 있다) 그 중에서도 `createRandom` 메소드를 사용해보자. `createRandom` 은 임의로 사용 가능한 암호학적 리소스를 통해 랜덤으로 private key와 지갑을 생성한다. 

console.log는 `const 변수명` 에 적힌 부분에서 변수명에 어떤 값이 담겨있는지 출력해주는 함수이다. 

```jsx
const privateKey = wallet.privateKey;
console.log('Private key:', privateKey);
```

그런 다음, wallet 클래스에서 private key를 확인해보는 단계이다. 

```jsx
const address = wallet.address;
console.log('My ethereum address:',address);
```

마지막으로는 어떤 주소가 생성되었는지 wallet 클래스의 address를 통해 알아보도록 하자. 

### 코드 실행을 위해 package.json에 script 명령어 추가

```jsx
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "node src/index.js"
  },
```

Index.js 파일 내부에 우리가 필요한 코드들을 작성했으니 실행을 해봐야겠죠? 실행을 위해 아래와 같이 script 내부에 추가해준다. 

```jsx
  "dev": "node src/index.js"
```

### 실행

```jsx
npm run dev
```

Index.js 파일을 실행하기 위해 터미널에서 npm run dev 를 입력해보자! 

### 실행 결과

```jsx
> ethereum-account-practice@1.0.0 dev
> node src/index.js

random wallet: HDNodeWallet {
  provider: null,
  address: '0x936c158285d5915ac5a94F00Dfbe0879dE1ca933',
  publicKey: '0x034783b92c44860725028ade8101f4353a891308a4a2118a268745c481cec475c8',
  fingerprint: '0xcc8bf869',
  parentFingerprint: '0x43723272',
  mnemonic: Mnemonic {
    phrase: 'motor noise wire short noble parrot relax exercise negative luggage prosper cover',
    password: '',
    wordlist: LangEn { locale: 'en' },
    entropy: '0x9072bbf0e3695b40ed427a93f09ab218'
  },
  chainCode: '0x3e840a199109d0820400cf7210a468639c1f9223eabfecb3f3688cb815f23194',
  path: "m/44'/60'/0'/0/0",
  index: 0,
  depth: 5
}
Private key: 0x8aba18880068b66932c7941e19fe0c4e9bf1026c02d0f1cb4811b0f301ab7bdd
My ethereum address: 0x936c158285d5915ac5a94F00Dfbe0879dE1ca933
```

실행 결과에서 정말 많은 값들이 나온다. 범위를 나누어보자면, 

1) random wallet

2) Private key

3) My ethereum address 

출력을 확인할 수 있다.

첫번째로 random하게 ethereum wallet을 생성해보았고, 그 안에 담긴 address와 mnemonic이라는 난수 12개로 설정되어 인코딩된 영단어 그룹과,private key를 주의깊게 보면된다. 

그리고 private key 그리고 mnemonic은 이더리움 wallet에서 보안을 위해 쓰이는 요소들이니 절대로 탈취되면 안된다는 사실 기억한다! 

이더리움 wallet을 만들어보는 실습을 진행해보았다. 

다음 단계부터는 위의 실습 내용을 바탕으로 이더리움 월렛에서 세부적으로 중요한 것들을 더 알아볼 차례이다. 

위의 4가지 단계를 다시 복기해 보자. 

우리는 ethers.js 라이브러리의 Wallet 클래스 내부의 private key를 통해 private key를 생성할 수 있었다. 이 private key를 통해 public key를 생성할 수 있다. 이것은 타원곡선 디지털 서명 알고리즘이라 불리는 ECDSA에 의해 가능하다. 

### Private key와 Public key의 관계

**Private key의 역할** 

- 무작위로 생성된 256bit의 정수값
- 지갑의 소유권을 증명하는 역할
- 정보를 해독하는데 사용되는 Key

**Public key의 역할**

- private key로 서명된 메시지나 트랜잭션을 검증하는 역할
- 정보를 암호화하는데 사용되는 Key
- Private key로부터 추출된다

private key와 public key는 1:1 매칭되며, 암호학에서 뗄레야 뗄 수 없는 관계이며 이더리움 wallet에서도 중요한 역할을 담당한다. 

### ECDSA로 public key를 생성하는 방법

ECDSA는 디지털 서명을 생성하고 서명하는데 사용되는 암호화 알고리즘입니다. ECDSA는 private key를 사용하여 메시지를 서명하고 public key를 통해 서명을 확인하는 방식으로 작동한다. 

우선, ECDSA로 private key로부터 public key를 추출하기 위해서는 elliptic 라이브러리 설치가 필요하다. 

elliptic 라이브러리 설치 

```jsx
npm install elliptic
```

elliptic 라이브러리([https://www.npmjs.com/package/elliptic](https://www.npmjs.com/package/elliptic))는 Javascript 환경에서 타원 곡선 암호화를 빠르게 진행시킬 수 있는 라이브러리 이다. 

```jsx
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');
```

설치한 elliptic 라이브러리를 사용하기 위해 require을 통해 가져온다. 

그리고 여기서 중요한 개념은 `secp256k1`이다. 이것은 이더리움에서 널리 사용되는 타원 곡선 알고리즘으로, `secp256k1`을 통해 EC 객체를 생성하여 서명 생성, 우리의 주 목적인 public key 생성을 도와주는 인터페이스이다. 

```jsx
const privateKey = '8aba18880068b66932c7941e19fe0c4e9bf1026c02d0f1cb4811b0f301ab7bdd';

const keyPair = ec.keyFromPrivate(privateKey);

```

위의 실습에서 진행한 결과로 나왔던 private key를 가져와보자. 주소 체계 접두어인 0x를 제외하고 순수한 값만 비교하기 위해 0x를 제외한 값만 가져온다. 

그리고 나서 위에서 생성한 ec 객체에 접근하여 private key를 컴퓨터가 읽을 수 있도록 keyFromPrivate 메소드를 통해 입력된 private key 문자열을 통해 타원 곡선 연산을 진행하고, private key로부터 파생된 public key의 keyPair를 생성합니다. 

```jsx
const myPublicKey = keyPair.getPublic().encodeCompressed('hex');
console.log('myPublicKey:::',myPublicKey);
```

생성된 keyPair의 `getPublic()` 메소드를 이용한다. `getPublic()`은 elliptic 라이브러리에서 제공되는 메소드로 생성된 keyPair에서 public key를 추출하는 역할을 한다. 

추출된 public key를 hex를 이용하여 16진수로 표현한다. 이더리움의 Public key는 16진수로 표현되기 때문이다.

여기서 위에서 실습으로 진행한 Public key와 같은 값이 출력된다. 
(정말 신기지 않은가?) 

```jsx
0x034783b92c44860725028ade8101f4353a891308a4a2118a268745c481cec475c8
```

```jsx
034783b92c44860725028ade8101f4353a891308a4a2118a268745c481cec475c8
```

위에서 `encodeCompressed('hex');` 라는 값을 사용했했다. 그 이유에 대해 설명하겠다. 

이는 타원 곡선 암호화 방식에서 사용되는 ‘압축된 공개 키’ 방식으로, 압축된 공개 키를 사용함으로써 네트워크 트래픽 속도, 데이터 처리 속도 향상 등의 측면에서 이점이 있어 사용된다. 

만약 공개키를 압축하지 않았다면 아래와 같이 데이터의 길이가 긴 Public key 값이 생성되었으며 데이터 크기가 크며, 전송 측면에서도 느린 속도를 보여주었을 것이다. 

```jsx
044783b92c44860725028ade8101f4353a891308a4a2118a268745c481cec475c8f47f0a73b01cda4ead248d786e8d0d2e099269ca63e76aaeb557fe3bec81d1f5
```

이렇게 ethers.js를 통해 블록체인 Account를 만들어보는 실습을 진행했다.
